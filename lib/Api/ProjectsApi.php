<?php
/**
 * ProjectsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * API V2
 *
 * Connect your software to POEditor with this simple API
 *
 * The version of the OpenAPI document: 1.0.3
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.5.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * ProjectsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ProjectsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'projectsAddPost' => [
            'application/x-www-form-urlencoded',
        ],
        'projectsDeletePost' => [
            'application/x-www-form-urlencoded',
        ],
        'projectsExportPost' => [
            'application/x-www-form-urlencoded',
        ],
        'projectsListPost' => [
            'application/x-www-form-urlencoded',
        ],
        'projectsSyncPost' => [
            'application/x-www-form-urlencoded',
        ],
        'projectsUpdatePost' => [
            'application/x-www-form-urlencoded',
        ],
        'projectsUploadPost' => [
            'multipart/form-data',
        ],
        'projectsViewPost' => [
            'application/x-www-form-urlencoded',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation projectsAddPost
     *
     * Creates a new project. Returns project details (if successful)
     *
     * @param  string $api_token api_token (required)
     * @param  string $name name (required)
     * @param  string $description description (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsAddPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProjectViewResponse
     */
    public function projectsAddPost($api_token, $name, $description = null, string $contentType = self::contentTypes['projectsAddPost'][0])
    {
        list($response) = $this->projectsAddPostWithHttpInfo($api_token, $name, $description, $contentType);
        return $response;
    }

    /**
     * Operation projectsAddPostWithHttpInfo
     *
     * Creates a new project. Returns project details (if successful)
     *
     * @param  string $api_token (required)
     * @param  string $name (required)
     * @param  string $description (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsAddPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProjectViewResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function projectsAddPostWithHttpInfo($api_token, $name, $description = null, string $contentType = self::contentTypes['projectsAddPost'][0])
    {
        $request = $this->projectsAddPostRequest($api_token, $name, $description, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProjectViewResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProjectViewResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProjectViewResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProjectViewResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProjectViewResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation projectsAddPostAsync
     *
     * Creates a new project. Returns project details (if successful)
     *
     * @param  string $api_token (required)
     * @param  string $name (required)
     * @param  string $description (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsAddPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsAddPostAsync($api_token, $name, $description = null, string $contentType = self::contentTypes['projectsAddPost'][0])
    {
        return $this->projectsAddPostAsyncWithHttpInfo($api_token, $name, $description, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation projectsAddPostAsyncWithHttpInfo
     *
     * Creates a new project. Returns project details (if successful)
     *
     * @param  string $api_token (required)
     * @param  string $name (required)
     * @param  string $description (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsAddPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsAddPostAsyncWithHttpInfo($api_token, $name, $description = null, string $contentType = self::contentTypes['projectsAddPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProjectViewResponse';
        $request = $this->projectsAddPostRequest($api_token, $name, $description, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'projectsAddPost'
     *
     * @param  string $api_token (required)
     * @param  string $name (required)
     * @param  string $description (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsAddPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function projectsAddPostRequest($api_token, $name, $description = null, string $contentType = self::contentTypes['projectsAddPost'][0])
    {

        // verify the required parameter 'api_token' is set
        if ($api_token === null || (is_array($api_token) && count($api_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_token when calling projectsAddPost'
            );
        }

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling projectsAddPost'
            );
        }



        $resourcePath = '/projects/add';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($api_token !== null) {
            $formParams['api_token'] = ObjectSerializer::toFormValue($api_token);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation projectsDeletePost
     *
     * Deletes the project from the account. You must be the owner of the project.
     *
     * @param  string $api_token api_token (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsDeletePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Response
     */
    public function projectsDeletePost($api_token, $id, string $contentType = self::contentTypes['projectsDeletePost'][0])
    {
        list($response) = $this->projectsDeletePostWithHttpInfo($api_token, $id, $contentType);
        return $response;
    }

    /**
     * Operation projectsDeletePostWithHttpInfo
     *
     * Deletes the project from the account. You must be the owner of the project.
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsDeletePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function projectsDeletePostWithHttpInfo($api_token, $id, string $contentType = self::contentTypes['projectsDeletePost'][0])
    {
        $request = $this->projectsDeletePostRequest($api_token, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Response' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation projectsDeletePostAsync
     *
     * Deletes the project from the account. You must be the owner of the project.
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsDeletePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsDeletePostAsync($api_token, $id, string $contentType = self::contentTypes['projectsDeletePost'][0])
    {
        return $this->projectsDeletePostAsyncWithHttpInfo($api_token, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation projectsDeletePostAsyncWithHttpInfo
     *
     * Deletes the project from the account. You must be the owner of the project.
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsDeletePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsDeletePostAsyncWithHttpInfo($api_token, $id, string $contentType = self::contentTypes['projectsDeletePost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Response';
        $request = $this->projectsDeletePostRequest($api_token, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'projectsDeletePost'
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsDeletePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function projectsDeletePostRequest($api_token, $id, string $contentType = self::contentTypes['projectsDeletePost'][0])
    {

        // verify the required parameter 'api_token' is set
        if ($api_token === null || (is_array($api_token) && count($api_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_token when calling projectsDeletePost'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling projectsDeletePost'
            );
        }


        $resourcePath = '/projects/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($api_token !== null) {
            $formParams['api_token'] = ObjectSerializer::toFormValue($api_token);
        }
        // form params
        if ($id !== null) {
            $formParams['id'] = ObjectSerializer::toFormValue($id);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation projectsExportPost
     *
     * Returns the link of the file (expires after 10 minutes). The settings inherited from the project will be the ones at the time of the download.
     *
     * @param  string $api_token api_token (required)
     * @param  int $id id (required)
     * @param  string $language language (required)
     * @param  string $type type (required)
     * @param  string $filters filters (optional)
     * @param  string $order order (optional)
     * @param  string $tags tags (optional)
     * @param  string $options options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsExportPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProjectExportResponse
     */
    public function projectsExportPost($api_token, $id, $language, $type, $filters = null, $order = null, $tags = null, $options = null, string $contentType = self::contentTypes['projectsExportPost'][0])
    {
        list($response) = $this->projectsExportPostWithHttpInfo($api_token, $id, $language, $type, $filters, $order, $tags, $options, $contentType);
        return $response;
    }

    /**
     * Operation projectsExportPostWithHttpInfo
     *
     * Returns the link of the file (expires after 10 minutes). The settings inherited from the project will be the ones at the time of the download.
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $language (required)
     * @param  string $type (required)
     * @param  string $filters (optional)
     * @param  string $order (optional)
     * @param  string $tags (optional)
     * @param  string $options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsExportPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProjectExportResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function projectsExportPostWithHttpInfo($api_token, $id, $language, $type, $filters = null, $order = null, $tags = null, $options = null, string $contentType = self::contentTypes['projectsExportPost'][0])
    {
        $request = $this->projectsExportPostRequest($api_token, $id, $language, $type, $filters, $order, $tags, $options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProjectExportResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProjectExportResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProjectExportResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProjectExportResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProjectExportResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation projectsExportPostAsync
     *
     * Returns the link of the file (expires after 10 minutes). The settings inherited from the project will be the ones at the time of the download.
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $language (required)
     * @param  string $type (required)
     * @param  string $filters (optional)
     * @param  string $order (optional)
     * @param  string $tags (optional)
     * @param  string $options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsExportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsExportPostAsync($api_token, $id, $language, $type, $filters = null, $order = null, $tags = null, $options = null, string $contentType = self::contentTypes['projectsExportPost'][0])
    {
        return $this->projectsExportPostAsyncWithHttpInfo($api_token, $id, $language, $type, $filters, $order, $tags, $options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation projectsExportPostAsyncWithHttpInfo
     *
     * Returns the link of the file (expires after 10 minutes). The settings inherited from the project will be the ones at the time of the download.
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $language (required)
     * @param  string $type (required)
     * @param  string $filters (optional)
     * @param  string $order (optional)
     * @param  string $tags (optional)
     * @param  string $options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsExportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsExportPostAsyncWithHttpInfo($api_token, $id, $language, $type, $filters = null, $order = null, $tags = null, $options = null, string $contentType = self::contentTypes['projectsExportPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProjectExportResponse';
        $request = $this->projectsExportPostRequest($api_token, $id, $language, $type, $filters, $order, $tags, $options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'projectsExportPost'
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $language (required)
     * @param  string $type (required)
     * @param  string $filters (optional)
     * @param  string $order (optional)
     * @param  string $tags (optional)
     * @param  string $options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsExportPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function projectsExportPostRequest($api_token, $id, $language, $type, $filters = null, $order = null, $tags = null, $options = null, string $contentType = self::contentTypes['projectsExportPost'][0])
    {

        // verify the required parameter 'api_token' is set
        if ($api_token === null || (is_array($api_token) && count($api_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_token when calling projectsExportPost'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling projectsExportPost'
            );
        }

        // verify the required parameter 'language' is set
        if ($language === null || (is_array($language) && count($language) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $language when calling projectsExportPost'
            );
        }

        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling projectsExportPost'
            );
        }






        $resourcePath = '/projects/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($api_token !== null) {
            $formParams['api_token'] = ObjectSerializer::toFormValue($api_token);
        }
        // form params
        if ($id !== null) {
            $formParams['id'] = ObjectSerializer::toFormValue($id);
        }
        // form params
        if ($language !== null) {
            $formParams['language'] = ObjectSerializer::toFormValue($language);
        }
        // form params
        if ($type !== null) {
            $formParams['type'] = ObjectSerializer::toFormValue($type);
        }
        // form params
        if ($filters !== null) {
            $formParams['filters'] = ObjectSerializer::toFormValue($filters);
        }
        // form params
        if ($order !== null) {
            $formParams['order'] = ObjectSerializer::toFormValue($order);
        }
        // form params
        if ($tags !== null) {
            $formParams['tags'] = ObjectSerializer::toFormValue($tags);
        }
        // form params
        if ($options !== null) {
            $formParams['options'] = ObjectSerializer::toFormValue($options);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation projectsListPost
     *
     * Returns the list of projects owned by user.
     *
     * @param  string $api_token api_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsListPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProjectListResponse
     */
    public function projectsListPost($api_token, string $contentType = self::contentTypes['projectsListPost'][0])
    {
        list($response) = $this->projectsListPostWithHttpInfo($api_token, $contentType);
        return $response;
    }

    /**
     * Operation projectsListPostWithHttpInfo
     *
     * Returns the list of projects owned by user.
     *
     * @param  string $api_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsListPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProjectListResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function projectsListPostWithHttpInfo($api_token, string $contentType = self::contentTypes['projectsListPost'][0])
    {
        $request = $this->projectsListPostRequest($api_token, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProjectListResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProjectListResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProjectListResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProjectListResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProjectListResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation projectsListPostAsync
     *
     * Returns the list of projects owned by user.
     *
     * @param  string $api_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsListPostAsync($api_token, string $contentType = self::contentTypes['projectsListPost'][0])
    {
        return $this->projectsListPostAsyncWithHttpInfo($api_token, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation projectsListPostAsyncWithHttpInfo
     *
     * Returns the list of projects owned by user.
     *
     * @param  string $api_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsListPostAsyncWithHttpInfo($api_token, string $contentType = self::contentTypes['projectsListPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProjectListResponse';
        $request = $this->projectsListPostRequest($api_token, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'projectsListPost'
     *
     * @param  string $api_token (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsListPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function projectsListPostRequest($api_token, string $contentType = self::contentTypes['projectsListPost'][0])
    {

        // verify the required parameter 'api_token' is set
        if ($api_token === null || (is_array($api_token) && count($api_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_token when calling projectsListPost'
            );
        }


        $resourcePath = '/projects/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($api_token !== null) {
            $formParams['api_token'] = ObjectSerializer::toFormValue($api_token);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation projectsSyncPost
     *
     * Syncs your project with the array you send (terms that are not found in the JSON object will be deleted from project and the new ones added). Please use with caution. If wrong data is sent, existing terms and their translations might be irreversibly lost.
     *
     * @param  string $api_token api_token (required)
     * @param  int $id id (required)
     * @param  string $data data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsSyncPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProjectSyncResponse
     */
    public function projectsSyncPost($api_token, $id, $data, string $contentType = self::contentTypes['projectsSyncPost'][0])
    {
        list($response) = $this->projectsSyncPostWithHttpInfo($api_token, $id, $data, $contentType);
        return $response;
    }

    /**
     * Operation projectsSyncPostWithHttpInfo
     *
     * Syncs your project with the array you send (terms that are not found in the JSON object will be deleted from project and the new ones added). Please use with caution. If wrong data is sent, existing terms and their translations might be irreversibly lost.
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsSyncPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProjectSyncResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function projectsSyncPostWithHttpInfo($api_token, $id, $data, string $contentType = self::contentTypes['projectsSyncPost'][0])
    {
        $request = $this->projectsSyncPostRequest($api_token, $id, $data, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProjectSyncResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProjectSyncResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProjectSyncResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProjectSyncResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProjectSyncResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation projectsSyncPostAsync
     *
     * Syncs your project with the array you send (terms that are not found in the JSON object will be deleted from project and the new ones added). Please use with caution. If wrong data is sent, existing terms and their translations might be irreversibly lost.
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsSyncPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsSyncPostAsync($api_token, $id, $data, string $contentType = self::contentTypes['projectsSyncPost'][0])
    {
        return $this->projectsSyncPostAsyncWithHttpInfo($api_token, $id, $data, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation projectsSyncPostAsyncWithHttpInfo
     *
     * Syncs your project with the array you send (terms that are not found in the JSON object will be deleted from project and the new ones added). Please use with caution. If wrong data is sent, existing terms and their translations might be irreversibly lost.
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsSyncPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsSyncPostAsyncWithHttpInfo($api_token, $id, $data, string $contentType = self::contentTypes['projectsSyncPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProjectSyncResponse';
        $request = $this->projectsSyncPostRequest($api_token, $id, $data, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'projectsSyncPost'
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $data (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsSyncPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function projectsSyncPostRequest($api_token, $id, $data, string $contentType = self::contentTypes['projectsSyncPost'][0])
    {

        // verify the required parameter 'api_token' is set
        if ($api_token === null || (is_array($api_token) && count($api_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_token when calling projectsSyncPost'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling projectsSyncPost'
            );
        }

        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling projectsSyncPost'
            );
        }


        $resourcePath = '/projects/sync';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($api_token !== null) {
            $formParams['api_token'] = ObjectSerializer::toFormValue($api_token);
        }
        // form params
        if ($id !== null) {
            $formParams['id'] = ObjectSerializer::toFormValue($id);
        }
        // form params
        if ($data !== null) {
            $formParams['data'] = ObjectSerializer::toFormValue($data);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation projectsUpdatePost
     *
     * Updates project settings (name, description, reference language, fallback language). If optional parameters are not sent, their respective fields are not updated.
     *
     * @param  string $api_token api_token (required)
     * @param  int $id id (required)
     * @param  string $name name (optional)
     * @param  string $description description (optional)
     * @param  string $reference_language reference_language (optional)
     * @param  string $fallback_language fallback_language (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsUpdatePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProjectViewResponse
     */
    public function projectsUpdatePost($api_token, $id, $name = null, $description = null, $reference_language = null, $fallback_language = null, string $contentType = self::contentTypes['projectsUpdatePost'][0])
    {
        list($response) = $this->projectsUpdatePostWithHttpInfo($api_token, $id, $name, $description, $reference_language, $fallback_language, $contentType);
        return $response;
    }

    /**
     * Operation projectsUpdatePostWithHttpInfo
     *
     * Updates project settings (name, description, reference language, fallback language). If optional parameters are not sent, their respective fields are not updated.
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  string $reference_language (optional)
     * @param  string $fallback_language (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsUpdatePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProjectViewResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function projectsUpdatePostWithHttpInfo($api_token, $id, $name = null, $description = null, $reference_language = null, $fallback_language = null, string $contentType = self::contentTypes['projectsUpdatePost'][0])
    {
        $request = $this->projectsUpdatePostRequest($api_token, $id, $name, $description, $reference_language, $fallback_language, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProjectViewResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProjectViewResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProjectViewResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProjectViewResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProjectViewResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation projectsUpdatePostAsync
     *
     * Updates project settings (name, description, reference language, fallback language). If optional parameters are not sent, their respective fields are not updated.
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  string $reference_language (optional)
     * @param  string $fallback_language (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsUpdatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsUpdatePostAsync($api_token, $id, $name = null, $description = null, $reference_language = null, $fallback_language = null, string $contentType = self::contentTypes['projectsUpdatePost'][0])
    {
        return $this->projectsUpdatePostAsyncWithHttpInfo($api_token, $id, $name, $description, $reference_language, $fallback_language, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation projectsUpdatePostAsyncWithHttpInfo
     *
     * Updates project settings (name, description, reference language, fallback language). If optional parameters are not sent, their respective fields are not updated.
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  string $reference_language (optional)
     * @param  string $fallback_language (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsUpdatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsUpdatePostAsyncWithHttpInfo($api_token, $id, $name = null, $description = null, $reference_language = null, $fallback_language = null, string $contentType = self::contentTypes['projectsUpdatePost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProjectViewResponse';
        $request = $this->projectsUpdatePostRequest($api_token, $id, $name, $description, $reference_language, $fallback_language, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'projectsUpdatePost'
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $name (optional)
     * @param  string $description (optional)
     * @param  string $reference_language (optional)
     * @param  string $fallback_language (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsUpdatePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function projectsUpdatePostRequest($api_token, $id, $name = null, $description = null, $reference_language = null, $fallback_language = null, string $contentType = self::contentTypes['projectsUpdatePost'][0])
    {

        // verify the required parameter 'api_token' is set
        if ($api_token === null || (is_array($api_token) && count($api_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_token when calling projectsUpdatePost'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling projectsUpdatePost'
            );
        }






        $resourcePath = '/projects/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($api_token !== null) {
            $formParams['api_token'] = ObjectSerializer::toFormValue($api_token);
        }
        // form params
        if ($id !== null) {
            $formParams['id'] = ObjectSerializer::toFormValue($id);
        }
        // form params
        if ($name !== null) {
            $formParams['name'] = ObjectSerializer::toFormValue($name);
        }
        // form params
        if ($description !== null) {
            $formParams['description'] = ObjectSerializer::toFormValue($description);
        }
        // form params
        if ($reference_language !== null) {
            $formParams['reference_language'] = ObjectSerializer::toFormValue($reference_language);
        }
        // form params
        if ($fallback_language !== null) {
            $formParams['fallback_language'] = ObjectSerializer::toFormValue($fallback_language);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation projectsUploadPost
     *
     * Updates terms / translations - No more than one request every 30 seconds.
     *
     * @param  string $updating updating (required)
     * @param  \SplFileObject $file Uploaded file (.po, .xls or any of the supported file formats) (required)
     * @param  string $api_token api_token (optional)
     * @param  int $id id (optional)
     * @param  string $language The language code (Required only if &#x60;updating&#x60; is terms_translations or translations) (optional)
     * @param  int $overwrite Set it to 1 if you want to overwrite translations (optional)
     * @param  int $sync_terms Set it to 1 if you want to sync your terms (terms that are not found in the uploaded file will be deleted from project and the new ones added). Ignored if &#x60;updating&#x60; &#x3D; translations. (optional)
     * @param  string $tags Add tags to the project terms; available when updating terms or terms_translations; you can use the following keys: \\\&quot;all\\\&quot; - for the all the imported terms, \\\&quot;new\\\&quot; - for the terms which arent already in the project, \\\&quot;obsolete\\\&quot; - for the terms which are in the project but not in the imported file and \\\&quot;overwritten_translations\\\&quot; - for the terms for which translations change (optional)
     * @param  int $read_from_source For .xliff format only - set it to 1 if you want to import translations from the source tag (optional)
     * @param  int $fuzzy_trigger Set it to 1 to mark corresponding translations from the other languages as fuzzy for the updated values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsUploadPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProjectUploadResponse
     */
    public function projectsUploadPost($updating, $file, $api_token = null, $id = null, $language = null, $overwrite = null, $sync_terms = null, $tags = null, $read_from_source = null, $fuzzy_trigger = null, string $contentType = self::contentTypes['projectsUploadPost'][0])
    {
        list($response) = $this->projectsUploadPostWithHttpInfo($updating, $file, $api_token, $id, $language, $overwrite, $sync_terms, $tags, $read_from_source, $fuzzy_trigger, $contentType);
        return $response;
    }

    /**
     * Operation projectsUploadPostWithHttpInfo
     *
     * Updates terms / translations - No more than one request every 30 seconds.
     *
     * @param  string $updating (required)
     * @param  \SplFileObject $file Uploaded file (.po, .xls or any of the supported file formats) (required)
     * @param  string $api_token (optional)
     * @param  int $id (optional)
     * @param  string $language The language code (Required only if &#x60;updating&#x60; is terms_translations or translations) (optional)
     * @param  int $overwrite Set it to 1 if you want to overwrite translations (optional)
     * @param  int $sync_terms Set it to 1 if you want to sync your terms (terms that are not found in the uploaded file will be deleted from project and the new ones added). Ignored if &#x60;updating&#x60; &#x3D; translations. (optional)
     * @param  string $tags Add tags to the project terms; available when updating terms or terms_translations; you can use the following keys: \\\&quot;all\\\&quot; - for the all the imported terms, \\\&quot;new\\\&quot; - for the terms which arent already in the project, \\\&quot;obsolete\\\&quot; - for the terms which are in the project but not in the imported file and \\\&quot;overwritten_translations\\\&quot; - for the terms for which translations change (optional)
     * @param  int $read_from_source For .xliff format only - set it to 1 if you want to import translations from the source tag (optional)
     * @param  int $fuzzy_trigger Set it to 1 to mark corresponding translations from the other languages as fuzzy for the updated values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsUploadPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProjectUploadResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function projectsUploadPostWithHttpInfo($updating, $file, $api_token = null, $id = null, $language = null, $overwrite = null, $sync_terms = null, $tags = null, $read_from_source = null, $fuzzy_trigger = null, string $contentType = self::contentTypes['projectsUploadPost'][0])
    {
        $request = $this->projectsUploadPostRequest($updating, $file, $api_token, $id, $language, $overwrite, $sync_terms, $tags, $read_from_source, $fuzzy_trigger, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProjectUploadResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProjectUploadResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProjectUploadResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProjectUploadResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProjectUploadResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation projectsUploadPostAsync
     *
     * Updates terms / translations - No more than one request every 30 seconds.
     *
     * @param  string $updating (required)
     * @param  \SplFileObject $file Uploaded file (.po, .xls or any of the supported file formats) (required)
     * @param  string $api_token (optional)
     * @param  int $id (optional)
     * @param  string $language The language code (Required only if &#x60;updating&#x60; is terms_translations or translations) (optional)
     * @param  int $overwrite Set it to 1 if you want to overwrite translations (optional)
     * @param  int $sync_terms Set it to 1 if you want to sync your terms (terms that are not found in the uploaded file will be deleted from project and the new ones added). Ignored if &#x60;updating&#x60; &#x3D; translations. (optional)
     * @param  string $tags Add tags to the project terms; available when updating terms or terms_translations; you can use the following keys: \\\&quot;all\\\&quot; - for the all the imported terms, \\\&quot;new\\\&quot; - for the terms which arent already in the project, \\\&quot;obsolete\\\&quot; - for the terms which are in the project but not in the imported file and \\\&quot;overwritten_translations\\\&quot; - for the terms for which translations change (optional)
     * @param  int $read_from_source For .xliff format only - set it to 1 if you want to import translations from the source tag (optional)
     * @param  int $fuzzy_trigger Set it to 1 to mark corresponding translations from the other languages as fuzzy for the updated values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsUploadPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsUploadPostAsync($updating, $file, $api_token = null, $id = null, $language = null, $overwrite = null, $sync_terms = null, $tags = null, $read_from_source = null, $fuzzy_trigger = null, string $contentType = self::contentTypes['projectsUploadPost'][0])
    {
        return $this->projectsUploadPostAsyncWithHttpInfo($updating, $file, $api_token, $id, $language, $overwrite, $sync_terms, $tags, $read_from_source, $fuzzy_trigger, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation projectsUploadPostAsyncWithHttpInfo
     *
     * Updates terms / translations - No more than one request every 30 seconds.
     *
     * @param  string $updating (required)
     * @param  \SplFileObject $file Uploaded file (.po, .xls or any of the supported file formats) (required)
     * @param  string $api_token (optional)
     * @param  int $id (optional)
     * @param  string $language The language code (Required only if &#x60;updating&#x60; is terms_translations or translations) (optional)
     * @param  int $overwrite Set it to 1 if you want to overwrite translations (optional)
     * @param  int $sync_terms Set it to 1 if you want to sync your terms (terms that are not found in the uploaded file will be deleted from project and the new ones added). Ignored if &#x60;updating&#x60; &#x3D; translations. (optional)
     * @param  string $tags Add tags to the project terms; available when updating terms or terms_translations; you can use the following keys: \\\&quot;all\\\&quot; - for the all the imported terms, \\\&quot;new\\\&quot; - for the terms which arent already in the project, \\\&quot;obsolete\\\&quot; - for the terms which are in the project but not in the imported file and \\\&quot;overwritten_translations\\\&quot; - for the terms for which translations change (optional)
     * @param  int $read_from_source For .xliff format only - set it to 1 if you want to import translations from the source tag (optional)
     * @param  int $fuzzy_trigger Set it to 1 to mark corresponding translations from the other languages as fuzzy for the updated values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsUploadPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsUploadPostAsyncWithHttpInfo($updating, $file, $api_token = null, $id = null, $language = null, $overwrite = null, $sync_terms = null, $tags = null, $read_from_source = null, $fuzzy_trigger = null, string $contentType = self::contentTypes['projectsUploadPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProjectUploadResponse';
        $request = $this->projectsUploadPostRequest($updating, $file, $api_token, $id, $language, $overwrite, $sync_terms, $tags, $read_from_source, $fuzzy_trigger, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'projectsUploadPost'
     *
     * @param  string $updating (required)
     * @param  \SplFileObject $file Uploaded file (.po, .xls or any of the supported file formats) (required)
     * @param  string $api_token (optional)
     * @param  int $id (optional)
     * @param  string $language The language code (Required only if &#x60;updating&#x60; is terms_translations or translations) (optional)
     * @param  int $overwrite Set it to 1 if you want to overwrite translations (optional)
     * @param  int $sync_terms Set it to 1 if you want to sync your terms (terms that are not found in the uploaded file will be deleted from project and the new ones added). Ignored if &#x60;updating&#x60; &#x3D; translations. (optional)
     * @param  string $tags Add tags to the project terms; available when updating terms or terms_translations; you can use the following keys: \\\&quot;all\\\&quot; - for the all the imported terms, \\\&quot;new\\\&quot; - for the terms which arent already in the project, \\\&quot;obsolete\\\&quot; - for the terms which are in the project but not in the imported file and \\\&quot;overwritten_translations\\\&quot; - for the terms for which translations change (optional)
     * @param  int $read_from_source For .xliff format only - set it to 1 if you want to import translations from the source tag (optional)
     * @param  int $fuzzy_trigger Set it to 1 to mark corresponding translations from the other languages as fuzzy for the updated values (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsUploadPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function projectsUploadPostRequest($updating, $file, $api_token = null, $id = null, $language = null, $overwrite = null, $sync_terms = null, $tags = null, $read_from_source = null, $fuzzy_trigger = null, string $contentType = self::contentTypes['projectsUploadPost'][0])
    {

        // verify the required parameter 'updating' is set
        if ($updating === null || (is_array($updating) && count($updating) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updating when calling projectsUploadPost'
            );
        }

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling projectsUploadPost'
            );
        }










        $resourcePath = '/projects/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($api_token !== null) {
            $formParams['api_token'] = ObjectSerializer::toFormValue($api_token);
        }
        // form params
        if ($id !== null) {
            $formParams['id'] = ObjectSerializer::toFormValue($id);
        }
        // form params
        if ($updating !== null) {
            $formParams['updating'] = ObjectSerializer::toFormValue($updating);
        }
        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // form params
        if ($language !== null) {
            $formParams['language'] = ObjectSerializer::toFormValue($language);
        }
        // form params
        if ($overwrite !== null) {
            $formParams['overwrite'] = ObjectSerializer::toFormValue($overwrite);
        }
        // form params
        if ($sync_terms !== null) {
            $formParams['sync_terms'] = ObjectSerializer::toFormValue($sync_terms);
        }
        // form params
        if ($tags !== null) {
            $formParams['tags'] = ObjectSerializer::toFormValue($tags);
        }
        // form params
        if ($read_from_source !== null) {
            $formParams['read_from_source'] = ObjectSerializer::toFormValue($read_from_source);
        }
        // form params
        if ($fuzzy_trigger !== null) {
            $formParams['fuzzy_trigger'] = ObjectSerializer::toFormValue($fuzzy_trigger);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation projectsViewPost
     *
     * Returns projects details
     *
     * @param  string $api_token api_token (required)
     * @param  int $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsViewPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProjectViewResponse
     */
    public function projectsViewPost($api_token, $id, string $contentType = self::contentTypes['projectsViewPost'][0])
    {
        list($response) = $this->projectsViewPostWithHttpInfo($api_token, $id, $contentType);
        return $response;
    }

    /**
     * Operation projectsViewPostWithHttpInfo
     *
     * Returns projects details
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsViewPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProjectViewResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function projectsViewPostWithHttpInfo($api_token, $id, string $contentType = self::contentTypes['projectsViewPost'][0])
    {
        $request = $this->projectsViewPostRequest($api_token, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProjectViewResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProjectViewResponse' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProjectViewResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProjectViewResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProjectViewResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation projectsViewPostAsync
     *
     * Returns projects details
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsViewPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsViewPostAsync($api_token, $id, string $contentType = self::contentTypes['projectsViewPost'][0])
    {
        return $this->projectsViewPostAsyncWithHttpInfo($api_token, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation projectsViewPostAsyncWithHttpInfo
     *
     * Returns projects details
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsViewPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function projectsViewPostAsyncWithHttpInfo($api_token, $id, string $contentType = self::contentTypes['projectsViewPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProjectViewResponse';
        $request = $this->projectsViewPostRequest($api_token, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'projectsViewPost'
     *
     * @param  string $api_token (required)
     * @param  int $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['projectsViewPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function projectsViewPostRequest($api_token, $id, string $contentType = self::contentTypes['projectsViewPost'][0])
    {

        // verify the required parameter 'api_token' is set
        if ($api_token === null || (is_array($api_token) && count($api_token) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_token when calling projectsViewPost'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling projectsViewPost'
            );
        }


        $resourcePath = '/projects/view';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($api_token !== null) {
            $formParams['api_token'] = ObjectSerializer::toFormValue($api_token);
        }
        // form params
        if ($id !== null) {
            $formParams['id'] = ObjectSerializer::toFormValue($id);
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
